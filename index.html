<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>clj-uuid by danlentz</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>clj-uuid</h1>
        <p>A Clojure library extending java.util.UUID with true v1 (time based) and v3/v5 (namespace based) identifiers</p>

        <p class="view"><a href="https://github.com/danlentz/clj-uuid">View the Project on GitHub <small>danlentz/clj-uuid</small></a></p>


        <ul>
          <li><a href="https://github.com/danlentz/clj-uuid/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/danlentz/clj-uuid/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/danlentz/clj-uuid">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="clj-uuid" class="anchor" href="#clj-uuid" aria-hidden="true"><span class="octicon octicon-link"></span></a>clj-uuid</h1>

<p><a href="https://travis-ci.org/danlentz/clj-uuid"><img src="https://travis-ci.org/danlentz/clj-uuid.svg?branch=master" alt="Build Status"></a>
<a href="https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.2-SNAPSHOT"><img src="https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.2-SNAPSHOT/badge.svg" alt="Dependency Status"></a></p>

<hr>

<p><strong>clj-uuid</strong> is a Clojure library for generation and utilization of
UUIDs (Universally Unique Identifiers) as described by RFC-4122.
This library extends the standard Java UUID class to provide true v1
(time based) and v3/v5 (namespace based) identifier generation.
Additionally, a number of useful supporting utilities are provided to
support serialization and manipulation of these UUIDs in a simple,
efficient manner.</p>

<p>The essential nature of the value RFC4122 UUIDs provide is that of an
enormous namespace and a deterministic mathematical model by means of
which one navigates it. UUIDs represent an extremely powerful and
versatile computation technique that is often overlooked, and
underutilized. In my opinion, this, in part, is due to the generally
poor quality, performance, and capability of available libraries and,
in part, due to a general misunderstanding in the popular consiousness
of their proper use and benefit. It is my hope that this library will
serve to expand awareness, make available, and simplify use of RFC4122
identifiers to a wider audience.</p>

<h3>
<a id="the-most-recent-release" class="anchor" href="#the-most-recent-release" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Most Recent Release</h3>

<p>With Leiningen:</p>

<p><img src="http://clojars.org/danlentz/clj-uuid/latest-version.svg" alt="Clojars Project"></p>

<h3>
<a id="how-is-it-better" class="anchor" href="#how-is-it-better" aria-hidden="true"><span class="octicon octicon-link"></span></a>How is it better?</h3>

<p>The JVM version only provides an automatic builder for random (v4)
and (non-namespaced) pseudo-v3 UUID's.  Where appropriate, this library
does use the internal JVM UUID implementation.  The benefit with this library
is that clj-uuid provides an easy way to get v1 and true namespaced v3 and
v5 UUIDs.  v3/v5 UUID's are necessary because many of the interesting things
that you can do with UUID's require namespaced identifiers. v1 UUIDs are
really useful because they can be generated faster than v4's as they don't
need to call a cryptographic random number generator.</p>

<h3>
<a id="how-big" class="anchor" href="#how-big" aria-hidden="true"><span class="octicon octicon-link"></span></a>How Big?</h3>

<p>The provided namespace represents an <em>inexhaustable</em> resource and as
such can be used in a variety of ways not feasible using traditional
techniques rooted in the notions imposed by finite resources.  When I
say "inexhaustable" this of course is slight hyperbolie, but not by
much.  The upper bound on the representation implemented by this
library limits the number of unique identifiers to a mere...</p>

<p><em>three hundred forty undecillion two hundred eighty-two decillion three</em>
<em>hundred sixty-six nonillion nine hundred twenty octillion nine hundred</em> 
<em>thirty-eight septillion four hundred sixty-three sextillion four hundred</em>
<em>sixty-three quintillion three hundred seventy-four quadrillion six hundred</em>
<em>seven trillion four hundred thirty-one billion seven hundred sixty-eight</em>
<em>million two hundred eleven thousand four hundred and fifty-five.</em></p>

<p>If you think you might be starting to run low, let me know when you get down
to your last few undecillion or so and I'll see what I can do to help out.</p>

<h3>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h3>

<p>Using clj-uuid is really easy.  Docstrings are provided, but sometimes
examples help, too.  The following cases demonstrate about 90% of the
functionality that you are likely to ever need.</p>

<p>In order to refer to the symbols in this library, it is recommended to
<em>require</em> it in a given namespace:</p>

<div class="highlight highlight-clojure"><pre>
(<span class="pl-k">require</span> '[clj-uuid <span class="pl-c1">:as</span> uuid])</pre></div>

<p>Or include in namespace declaration:</p>

<div class="highlight highlight-clojure"><pre>
(<span class="pl-k">ns</span> <span class="pl-e">foo</span>
<span class="pl-e">  (<span class="pl-c1">:require</span> [clj-uuid <span class="pl-c1">:as</span> uuid])</span>
<span class="pl-e">  ...</span>
<span class="pl-e">  )</span>
<span class="pl-e"></span></pre></div>

<h4>
<a id="literal-syntax" class="anchor" href="#literal-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Literal Syntax</h4>

<p>UUID's have a convenient literal syntax supported by the clojure
reader.  The tag <code>#uuid</code> denotes that the following string literal
will be read as a UUID.  UUID's evaluate to themselves:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; #uuid <span class="pl-s1"><span class="pl-pds">"</span>e6ff478d-9492-48dd-886d-23ec4c6385ee<span class="pl-pds">"</span></span>

<span class="pl-c">;;  =&gt; #uuid "e6ff478d-9492-48dd-886d-23ec4c6385ee"</span></pre></div>

<h4>
<a id="the-null-v0-identifier" class="anchor" href="#the-null-v0-identifier" aria-hidden="true"><span class="octicon octicon-link"></span></a>The NULL (v0) Identifier</h4>

<p>The special UUID, <code>#uuid "00000000-0000-0000-0000-000000000000"</code> is
known as the <em>null UUID</em> or <em>version 0 UUID</em> and can be useful for
representing special values such as <em>nil</em> or _null-context. One may
reference the null UUID declaratively or functionally, although it is
best to pick one convention and remain consistant.</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/null</span>)

<span class="pl-c">;;  =&gt; #uuid "00000000-0000-0000-0000-000000000000"</span>


user&gt; (<span class="pl-en">uuid/v0</span>)

<span class="pl-c">;;  =&gt; #uuid "00000000-0000-0000-0000-000000000000"</span>


user&gt; uuid/+null+

<span class="pl-c">;;  =&gt; #uuid "00000000-0000-0000-0000-000000000000"</span>
</pre></div>

<h4>
<a id="time-based-v1-identifiers" class="anchor" href="#time-based-v1-identifiers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Time Based (v1) Identifiers</h4>

<p>You can make your own v1 UUID's with the function <code>#'uuid/v1</code>.  These
UUID's will be guaranteed to be unique and thread-safe regardless of
clock precision or degree of concurrency.</p>

<p>A v1 UUID may reveal both the identity of the computer that generated
the UUID and the time at which it did so.  Its uniqueness across
computers is guaranteed as long as node/MAC addresses are not duplicated.</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/v1</span>)

<span class="pl-c">;;  =&gt; #uuid "ffa803f0-b3d3-11e4-a03e-3af93c3de9ae"</span>

user&gt; (<span class="pl-en">uuid/v1</span>)

<span class="pl-c">;;  =&gt; #uuid "005b7570-b3d4-11e4-a03e-3af93c3de9ae"</span>

user&gt; (<span class="pl-en">uuid/v1</span>)

<span class="pl-c">;;  =&gt; #uuid "018a0a60-b3d4-11e4-a03e-3af93c3de9ae"</span>

user&gt; (<span class="pl-en">uuid/v1</span>)

<span class="pl-c">;;  =&gt; #uuid "02621ae0-b3d4-11e4-a03e-3af93c3de9ae"</span>
</pre></div>

<p>V1 identifiers are the fastest kind of UUID to generate -- about 25%
faster than calling the JVM's built-in static method for generating ids,
<code>#'java.util.UUID/randomUUID</code>.</p>

<pre><code>user&gt; (criterium.core/bench (uuid/v1))

Evaluation count : 41142600 in 60 samples of 685710 calls.
Execution time mean : 1.499075 µs
</code></pre>

<h4>
<a id="random-v4-identifiers" class="anchor" href="#random-v4-identifiers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random (v4) Identifiers</h4>

<p>V4 identifiers are generated by directly invoking the static method
<code>#'java.util.UUID/randomUUID</code> and are, in typical situations, slower
to generate in addition to being non-deterministically unique.</p>

<pre><code>user&gt; (criterium.core/bench (uuid/v4))

Evaluation count : 31754100 in 60 samples of 529235 calls.
Execution time mean : 1.928087 µs
</code></pre>

<h4>
<a id="namespaced-v3v5-identifiers" class="anchor" href="#namespaced-v3v5-identifiers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Namespaced (v3/v5) Identifiers</h4>

<p>If you are familiar wit Clojure <em>vars</em>, you already understand the
idea of <em>namespaced</em> identifiers.  To resolve the value of a var, one
needs to know not only the <em>name</em> of a var, but also the <em>namespace</em>
it resides in.  It is intuitively clear that vars <code>#'user/x</code> and
<code>#'library/x</code> are distinct.  Namespaced UUID's follow a similar
concept, however namespaces are themselves represented as UUID's.
Names are strings that encode a representation of a symbol or value in
the namespace of that identifier.  Given a namespace and a local-name,
one can always (re)construct the unique identifier that represents
it.  We can demonstrate a few examples constructed using several of
the canonical top level namespace UUIDs:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"</span>

user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-x500+ <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "0cb29677-4eaf-578f-ab9b-f9ac67c33cb9"</span>


user&gt; (<span class="pl-en">uuid/v3</span> uuid/+namespace-dns+ <span class="pl-s1"><span class="pl-pds">"</span>www.clojure.org<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "3bdca4f7-fc85-3a8b-9038-7626457527b0"</span>


user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-oid+ <span class="pl-s1"><span class="pl-pds">"</span>0.1.22.13.8.236.1<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "9989a7d2-b7fc-5b6a-84d6-556b0531a065"</span></pre></div>

<p>You can see in each case that the local "name" string is given in some
well-definted format specific to each namespace.  This is a very
common convention, but not enforced.  It is perfectly valid to
construct a namespaced UUID from any literal string.</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>I am clearly not a URL<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "a167a791-e550-57ae-b20f-666ee47ce7c1"</span></pre></div>

<p>The only difference between v3 and v5 UUID's is that v3's are computed
using an MD5 digest algorithm and v5's are computed using SHA1.  It is
generally considered that SHA1 is a superior hash, but MD5 is
computationally less expensive and so v3 may be preferred in
situations requiring slightly faster performance.</p>

<p>As a matter of fact, the requirements for a valid the local-part
constituent are even more general than even just Strings.  Any kind of
object can be used:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-c1">:keyword</span>)

<span class="pl-c">;;  =&gt; #uuid "bc480d53-fba7-5e5f-8f33-6ad77880a007"</span>

user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-c1">:keyword</span>)

<span class="pl-c">;;  =&gt; #uuid "bc480d53-fba7-5e5f-8f33-6ad77880a007"</span>


user&gt; (<span class="pl-en">uuid/v5</span> uuid/+namespace-oid+ <span class="pl-c1">:keyword</span>)

<span class="pl-c">;;  =&gt; #uuid "9b3d8a3d-fadf-55b5-811f-12a0c50c3e86"</span>
</pre></div>

<p>This will be most efficient for classes of object that have been
extended with the <code>UUIDNameBytes</code> protocol.  If one intends to do such
a thing fequently, it is a simple matter to specialize an
<code>as-byte-array</code> method which can extract a unique sequence of bytes
from an arbitrary class of input data.  Here is a simple example where
one adds specialized support for URLs to be quickly digested as the bytes of
their string representation:</p>

<div class="highlight highlight-clojure"><pre>
(<span class="pl-en">extend-protocol</span> UUIDNameBytes java.net.URL
  (<span class="pl-en">as-byte-array</span> [this]
    (<span class="pl-en">.getBytes</span> (<span class="pl-en">.toString</span> this) StandardCharsets/UTF_8)))


(<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>)

<span class="pl-c">;; =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"</span>


(<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ (<span class="pl-en">java.net.URL.</span> <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>))

<span class="pl-c">;; =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"</span>
</pre></div>

<h5>
<a id="hierarchical-namespace" class="anchor" href="#hierarchical-namespace" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hierarchical Namespace</h5>

<p>Because each UUID denotes its own namespace, it is easy to compose v5
identifiers in order to represent hierarchical sub-namespaces.  This,
for example, can be used to assign unique identifiers based not only
on the content of a string but the unique identity representing its
source or provenance:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">uuid/v5</span>
        (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>)
        <span class="pl-s1"><span class="pl-pds">"</span>resource1#<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "6a3944a4-f00e-5921-b8b6-2cea5a745132"</span>


user&gt; (<span class="pl-en">uuid/v5</span>
        (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://example.com/<span class="pl-pds">"</span></span>)
        <span class="pl-s1"><span class="pl-pds">"</span>resource2#<span class="pl-pds">"</span></span>)

<span class="pl-c">;;  =&gt; #uuid "98879e2a-8511-59ab-877d-ac6f8667866d"</span>

user&gt; (<span class="pl-en">uuid/v5</span>
        (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://other.com/<span class="pl-pds">"</span></span>)
        <span class="pl-s1"><span class="pl-pds">"</span>resource1#<span class="pl-pds">"</span></span>)

user&gt; (<span class="pl-en">uuid/v5</span>
        (<span class="pl-en">uuid/v5</span> uuid/+namespace-url+ <span class="pl-s1"><span class="pl-pds">"</span>http://other.com/<span class="pl-pds">"</span></span>)
        <span class="pl-s1"><span class="pl-pds">"</span>resource2#<span class="pl-pds">"</span></span>)

</pre></div>

<p>Because UUID's and namespaces can be chained together like this, one
can be certain that the UUID resulting from a chain of calls such as
the following will be unique -- if and only if the original namespace
matches:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">-&gt;</span> (<span class="pl-en">uuid/v1</span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>))

<span class="pl-c">;;  =&gt; #uuid "eb7a0c2b-eb0e-5bb2-9819-3c9edc2814fa"</span>


user&gt; (<span class="pl-en">-&gt;</span> (<span class="pl-en">uuid/v1</span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>))

<span class="pl-c">;;  =&gt; #uuid "45e8c272-1660-57ba-8892-6844e1d3196a"</span>
</pre></div>

<p>At each step, the local part string must be identical, in order for the the
final UUID to match:</p>

<div class="highlight highlight-clojure"><pre>
user&gt; (<span class="pl-en">-&gt;</span> uuid/+namespace-dns+
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>))

<span class="pl-c">;;  =&gt; #uuid "617756cc-3b02-5a86-ad4a-ab3e1403dbd6"</span>


user&gt; (<span class="pl-en">-&gt;</span> uuid/+namespace-dns+
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>)
        (<span class="pl-en">uuid/v5</span> <span class="pl-s1"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>))

<span class="pl-c">;;  =&gt; #uuid "52d5453e-2aa1-53c1-b093-0ea20ef57ad1"</span>
</pre></div>

<p>This capability can be used to represent uniqueness of a sequence of
computations in, for example, a transaction system such as the one
used in the graph-object database system
<a href="http://github.com/lisp/de.setf.resource/">de.setf.resource</a>. </p>

<h3>
<a id="basic-api" class="anchor" href="#basic-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic API</h3>

<hr>

<p><em>(var)</em>         <code>+null+</code></p>

<blockquote>
<p><code>#uuid "00000000-0000-0000-0000-000000000000"</code></p>
</blockquote>

<p><em>(var)</em>         <code>+namespace-dns+</code></p>

<blockquote>
<p><code>#uuid "6ba7b810-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>

<p><em>(var)</em>         <code>+namespace-url+</code></p>

<blockquote>
<p><code>#uuid "6ba7b811-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>

<p><em>(var)</em>         <code>+namespace-oid+</code></p>

<blockquote>
<p><code>#uuid "6ba7b812-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>

<p><em>(var)</em>         <code>+namespace-x500+</code></p>

<blockquote>
<p><code>#uuid "6ba7b814-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>

<hr>

<p><em>(function)</em>    <code>v0 []</code></p>

<blockquote>
<p>Return the null UUID, #uuid "00000000-0000-0000-0000-000000000000"</p>
</blockquote>

<p><em>(function)</em>    <code>v1 []</code></p>

<blockquote>
<p>Generate a v1 (time-based) unique identifier, guaranteed to be unique
 and thread-safe regardless of clock precision or degree of concurrency.
 Creation of v1 UUID's does not require any call to a cryptographic 
 generator and can be accomplished much more efficiently than v1, v3, v5,
 or squuid's.  A v1 UUID reveals both the identity of the computer that 
 generated the UUID and the time at which it did so.  Its uniqueness across 
 computers is guaranteed as long as MAC addresses are not duplicated.</p>
</blockquote>

<p><em>(function)</em>    <code>v3 [^UUID namespace ^String local-name]</code></p>

<blockquote>
<p>Generate a v3 (name based, MD5 hash) UUID.</p>
</blockquote>

<p><em>(function)</em>    <code>v4 []</code></p>

<p><em>(function)</em>    <code>v4 [^long msb, ^long lsb]</code></p>

<blockquote>
<p>Generate a v4 (random) UUID.  Uses default JVM implementation.  If two
 arguments, lsb and msb (both long) are provided, then construct a valid,
 properly formatted v4 UUID based on those values.  So, for example the
 following UUID, created from all zero bits, is indeed distinct from the
 null UUID:</p>

<pre><code> (v4)
  =&gt; #uuid "dcf0035f-ea29-4d1c-b52e-4ea499c6323e"

 (v4 0 0)
  =&gt; #uuid "00000000-0000-4000-8000-000000000000"

 (null)
  =&gt; #uuid "00000000-0000-0000-0000-000000000000"
</code></pre>
</blockquote>

<p><em>(function)</em>    <code>v5 [^UUID namespace ^String local-name]</code></p>

<blockquote>
<p>Generate a v5 (name based, SHA1 hash) UUID.</p>
</blockquote>

<p><em>(function)</em>    <code>squuid []</code></p>

<blockquote>
<p>"Generate a SQUUID (sequential, random) unique identifier.  SQUUID's
 are a nonstandard variation on v4 (random) UUIDs that have the
 desirable property that they increase sequentially over time as well
 as encode retrievably the posix time at which they were generated.
 Splits and reassembles a v4 UUID to merge current POSIX
 time (seconds since 12:00am January 1, 1970 UTC) with the most
 significant 32 bits of the UUID</p>
</blockquote>

<hr>

<h3>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation</h3>

<p>To a large extent, the design of the algorithmic
implementation is inspired by the Common-Lisp library
<a href="http://github.com/mon-key/unicly"><em>UNICLY</em></a> which is a painstakingly
optimized, encyclopaedic implementation of RFC-4122 the author of
which, Stan Pearman, has devoted considerable effort to research, refine, and
improve.  To my knowledge there is no more performant  and
precise implementation of the RFC-4122 specification available
anywhere, in any language, on any platform.</p>

<p>That having been said, this library intends to present a slightly more
comfortable public interface that places a little more priority on
convenient DWIM semantics at the cost of somewhat less emphasis on
low level performance optimizations.  Since this library is built as
an extension to the standard java.util.UUID class whose implementation
largely dominates its performance characteristics anyway, this seems to
be a reasonable philosophy.</p>

<h3>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h3>

<p>Copyright © 2015 Dan Lentz</p>

<p>Distributed under the Eclipse Public License either version 1.0 </p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/danlentz">danlentz</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-37992128-5");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>