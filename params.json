{"name":"clj-uuid","tagline":"A Clojure library extending java.util.UUID with true v1 (time based) and v3/v5 (namespace based) identifiers","body":"clj-uuid\r\n========\r\n\r\n> _\"The intent of the UUID is to enable distributed systems to uniquely_ \r\n> _identify information without significant central coordination.\"_\r\n> -- [_Wikipedia/UUID_](http://en.wikipedia.org/wiki/Universally_unique_identifier)\r\n\r\n* * * * * *\r\n\r\n[![Build Status](https://travis-ci.org/danlentz/clj-uuid.svg?branch=master)]\r\n(https://travis-ci.org/danlentz/clj-uuid)[![Dependency Status](https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.4/badge.svg)](https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.4)\r\n\r\n\r\n**clj-uuid** is a Clojure library for generation and utilization of\r\nUUIDs (Universally Unique Identifiers) as described by\r\n[**IETF RFC4122**](http://www.ietf.org/rfc/rfc4122.txt).\r\n\r\nThis library extends the standard Java UUID class to provide true v1\r\n(time based) and v3/v5 (namespace based) identifier generation.\r\nAdditionally, a number of useful supporting utilities are provided to\r\nsupport serialization and manipulation of these UUIDs in a simple,\r\nefficient manner.\r\n\r\nThe essential nature of the value RFC4122 UUIDs provide is that of an\r\nenormous namespace and a deterministic mathematical model by means of\r\nwhich one navigates it. UUIDs represent an extremely powerful and\r\nversatile computation technique that is often overlooked, and\r\nunderutilized. In my opinion, this, in part, is due to the generally\r\npoor quality, performance, and capability of available libraries and,\r\nin part, due to a general misunderstanding in the popular consiousness\r\nof their proper use and benefit. It is my hope that this library will\r\nserve to expand awareness, make available, and simplify use of RFC4122\r\nidentifiers to a wider audience.\r\n\r\n\r\n\r\n### The Most Recent Release\r\n\r\nWith Leiningen:\r\n\r\n[![Clojars Project](http://clojars.org/danlentz/clj-uuid/latest-version.svg)](http://clojars.org/danlentz/clj-uuid)\r\n\r\n### How is it better?\r\n\r\nThe JVM version only provides an automatic generator for random (v4)\r\nand (non-namespaced) pseudo-v3 UUID's.  Where appropriate, this library\r\ndoes use the internal JVM UUID implementation.  The benefit with this library\r\nis that clj-uuid provides an easy way to get v1 and true namespaced v3 and\r\nv5 UUIDs.  v3/v5 UUID's are necessary because many of the interesting things\r\nthat you can do with UUID's require namespaced identifiers. v1 UUIDs are\r\nreally useful because they can be generated about **10x faster** than v4's since\r\nthey don't need to call a cryptographic random number generator.\r\n\r\n\r\n### How Big?\r\n\r\nThe provided namespace represents an _inexhaustable_ resource and as\r\nsuch can be used in a variety of ways not feasible using traditional\r\ntechniques rooted in the notions imposed by finite resources.  When I\r\nsay \"inexhaustable\" this of course is slight hyperbolie, but not by\r\nmuch.  The upper bound on the representation implemented by this\r\nlibrary limits the number of unique identifiers to a mere...\r\n\r\n*three hundred forty undecillion two hundred eighty-two decillion three*\r\n*hundred sixty-six nonillion nine hundred twenty octillion nine hundred* \r\n*thirty-eight septillion four hundred sixty-three sextillion four hundred*\r\n*sixty-three quintillion three hundred seventy-four quadrillion six hundred*\r\n*seven trillion four hundred thirty-one billion seven hundred sixty-eight*\r\n*million two hundred eleven thousand four hundred and fifty-five.*\r\n\r\nIf you think you might be starting to run low, let me know when you get down\r\nto your last few undecillion or so and I'll see what I can do to help out.\r\n\r\n\r\n### Usage\r\n\r\nUsing clj-uuid is really easy.  Docstrings are provided, but sometimes\r\nexamples help, too.  The following cases demonstrate about 90% of the\r\nfunctionality that you are likely to ever need.\r\n\r\nIn order to refer to the symbols in this library, it is recommended to\r\n*require* it in a given namespace:\r\n\r\n```clojure\r\n\r\n(require '[clj-uuid :as uuid])\r\n```\r\n\r\nOr include in namespace declaration:\r\n\r\n\r\n```clojure\r\n\r\n(ns foo\r\n  (:require [clj-uuid :as uuid])\r\n  ...\r\n  )\r\n\r\n```\r\n\r\n\r\n#### Literal Syntax\r\n\r\nUUID's have a convenient literal syntax supported by the clojure\r\nreader.  The tag `#uuid` denotes that the following string literal\r\nwill be read as a UUID.  UUID's evaluate to themselves:\r\n\r\n```clojure\r\n\r\nuser> #uuid \"e6ff478d-9492-48dd-886d-23ec4c6385ee\"\r\n\r\n;;  => #uuid \"e6ff478d-9492-48dd-886d-23ec4c6385ee\"\r\n```\r\n\r\n\r\n#### The NULL (v0) Identifier\r\n\r\nThe special UUID, `#uuid \"00000000-0000-0000-0000-000000000000\"` is\r\nknown as the _null UUID_ or _version 0 UUID_ and can be useful for\r\nrepresenting special values such as _nil_ or _null-context_. One may\r\nreference the null UUID declaratively or functionally, although it is\r\nbest to pick one convention and remain consistant.\r\n\r\n\r\n```clojure\r\n\r\nuser> (uuid/null)\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\nuser> (uuid/v0)\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\nuser> uuid/+null+\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n```\r\n\r\n\r\n#### Time Based (v1) Identifiers\r\n\r\nYou can make your own v1 UUID's with the function `#'uuid/v1`.  These\r\nUUID's will be guaranteed to be unique and thread-safe regardless of\r\nclock precision or degree of concurrency.\r\n\r\nA v1 UUID may reveal both the identity of the computer that generated\r\nthe UUID and the time at which it did so.  Its uniqueness across\r\ncomputers is guaranteed as long as node/MAC addresses are not duplicated.\r\n  \r\n\r\n```clojure\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"ffa803f0-b3d3-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"005b7570-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"018a0a60-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"02621ae0-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\n```\r\n\r\n\r\nV1 identifiers are the fastest kind of UUID to generate -- about _TEN TIMES\r\nas fast as calling the JVM's built-in static method for generating UUIDs_,\r\n`#'java.util.UUID/randomUUID`.\r\n\r\n\r\n```\r\nuser> (criterium.core/bench (uuid/v1))\r\n\r\nEvaluation count: 139356300 in 60 samples of 2322605 calls.\r\nExecution time mean: 201.153073 ns\r\n\r\n\r\nuser> (criterium/bench (java.util.UUID/randomUUID))\r\n\r\nEvaluation count : 30850980 in 60 samples of 514183 calls.\r\nExecution time mean : 2.012861 Âµs\r\n\r\n```\r\n\r\n##### Sequential (Temporal) Namespace\r\n\r\nv1 UUID's retrievably encode the time of their creation.  The native\r\nrepresentation of this timestamp is as a 60 bit value indicating the\r\nnumber of 100 nanosecond intervals since the Gregorian epoch:\r\n\r\n\r\n```clojure\r\n\r\nuser> (uuid/get-timestamp (uuid/v1))\r\n\r\n;;  => 136459064897650000\r\n\r\n\r\nuser> (map uuid/get-timestamp (repeatedly 10 uuid/v1))\r\n\r\n;;  => (136459065592300000\r\n;;      136459065592310000\r\n;;      136459065592320000\r\n;;      136459065592340000\r\n;;      136459065592340001 <-+ subcounter ensures unique timestamp\r\n;;      136459065592350000   | even when the resolution of the \r\n;;      136459065592350001 <-+ system clock is insufficiently\r\n;;      136459065592370000   | granular to provide uniqueness.\r\n;;      136459065592370001 <-+\r\n;;      136459065592380000)\r\n```\r\n\r\nClearly, that is pretty useful.  We can look at any two time-based\r\nUUID's and compare their timestamps relative to one another.  We can\r\nalso look at the absolute timestamp values of time-based UUID's using the\r\nideomatic Clojure representation of timestamp values:\r\n\r\n\r\n```clojure\r\n\r\nuser> (uuid/get-instant (uuid/v1))\r\n\r\n;;  => #inst \"2015-03-17T17:51:15.970-00:00\"\r\n\r\n\r\nuser> (map uuid/get-instant (repeatedly 10 uuid/v1))\r\n\r\n;;  => (#inst \"2015-03-17T17:51:53.800-00:00\" <-+ Note, however, \r\n;;      #inst \"2015-03-17T17:51:53.800-00:00\" <-+ insufficient clock precision\r\n;;      #inst \"2015-03-17T17:51:53.802-00:00\"   | to distinguish betweem\r\n;;      #inst \"2015-03-17T17:51:53.803-00:00\" <-+ absolute timestamp values\r\n;;      #inst \"2015-03-17T17:51:53.803-00:00\" <-+\r\n;;      #inst \"2015-03-17T17:51:53.804-00:00\"\r\n;;      #inst \"2015-03-17T17:51:53.807-00:00\"\r\n;;      #inst \"2015-03-17T17:51:53.808-00:00\"\r\n;;      #inst \"2015-03-17T17:51:53.812-00:00\"\r\n;;      #inst \"2015-03-17T17:51:53.814-00:00\")\r\n```\r\n\r\n\r\n#### Cryptographically Random (v4) Identifiers\r\n\r\n\r\nV4 identifiers are generated by directly invoking the static method\r\n`#'java.util.UUID/randomUUID` and are, in typical situations, slower\r\nto generate in addition to being non-deterministically unique. It\r\nexists primarily because it is very simple to implement and because\r\nrandomly generated UUID's are essentially unguessable.  They can be\r\nuseful in that sense, for example to seed a UUID namespace as we will see\r\nin a later example.\r\n\r\n\r\n#### Namespaced (v3/v5) Identifiers\r\n\r\nFirst of all, the only difference between v3 and v5 UUID's is that v3's\r\nare computed using an MD5 digest algorithm and v5's are computed using SHA1.\r\nIt is generally considered that SHA1 is a superior hash, but MD5 is\r\ncomputationally less expensive and so v3 may be preferred in\r\nsituations requiring slightly faster performance. As such, when we give\r\nexamples of namespaced identifiers, we will typically just use `v5` with\r\nthe understanding that `v3` could be used identically in each instance.\r\n\r\n##### Namespaces\r\n\r\nIf you are familiar with Clojure _vars_, you already understand the\r\nidea of _namespaced_ identifiers.  To resolve the value of a var, one\r\nneeds to know not only the _name_ of a var, but also the _namespace_\r\nit resides in.  It is intuitively clear that vars `#'user/x` and\r\n`#'library/x` are distinct.  Namespaced UUID's follow a similar\r\nconcept, however namespaces are themselves represented as UUID's.\r\nNames are strings that encode a representation of a symbol or value in\r\nthe namespace of that identifier.  Given a namespace and a local-name,\r\none can always (re)construct the unique identifier that represents\r\nit.  We can demonstrate a few examples constructed using several of\r\nthe canonical top level namespace UUIDs:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n\r\n;;  => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\nuser> (uuid/v5 uuid/+namespace-x500+ \"http://example.com/\")\r\n\r\n;;  => #uuid \"0cb29677-4eaf-578f-ab9b-f9ac67c33cb9\"\r\n\r\n\r\nuser> (uuid/v3 uuid/+namespace-dns+ \"www.clojure.org\")\r\n\r\n;;  => #uuid \"3bdca4f7-fc85-3a8b-9038-7626457527b0\"\r\n\r\n\r\nuser> (uuid/v5 uuid/+namespace-oid+ \"0.1.22.13.8.236.1\")\r\n\r\n;;  => #uuid \"9989a7d2-b7fc-5b6a-84d6-556b0531a065\"\r\n```\r\n\r\nYou can see in each case that the local \"name\" string is given in some\r\nwell-definted format specific to each namespace.  This is a very\r\ncommon convention, but not enforced.  It is perfectly valid to\r\nconstruct a namespaced UUID from any literal string.\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ \"I am clearly not a URL\")\r\n\r\n;;  => #uuid \"a167a791-e550-57ae-b20f-666ee47ce7c1\"\r\n```\r\n\r\nAs a matter of fact, the requirements for a valid the local-part\r\nconstituent are even more general than even just Strings.  Any kind of\r\nobject will do:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ :keyword)\r\n\r\n;;  => #uuid \"bc480d53-fba7-5e5f-8f33-6ad77880a007\"\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ :keyword)\r\n\r\n;;  => #uuid \"bc480d53-fba7-5e5f-8f33-6ad77880a007\"\r\n\r\nuser> (uuid/v5 uuid/+namespace-oid+ :keyword)\r\n\r\n;;  => #uuid \"9b3d8a3d-fadf-55b5-811f-12a0c50c3e86\"\r\n\r\n\r\n\r\nuser> (uuid/v5 uuid/+null+ 'this-symbol)\r\n\r\n;;  => #uuid \"8b2941d5-e40b-5364-afcf-0008833715a2\"\r\n\r\nuser> (uuid/v5 uuid/+null+ 'this-symbol)\r\n\r\n;;  => #uuid \"8b2941d5-e40b-5364-afcf-0008833715a2\"\r\n\r\n\r\n```\r\n\r\nThis will be most efficient for classes of object that have been\r\nextended with the `UUIDNameBytes` protocol.  If one intends to do such\r\na thing fequently, it is a simple matter to specialize an\r\n`as-byte-array` method which can extract a byte serialization that\r\nrepresents the 'name' of an object, typically unique within some given\r\nnamespace.  Here is a simple example where one adds specialized support\r\nfor URLs to be quickly digested as the bytes of their string representation.\r\n\r\n\r\n```clojure\r\n\r\n(extend-protocol UUIDNameBytes java.net.URL\r\n  (as-byte-array [this]\r\n    (.getBytes (.toString this) StandardCharsets/UTF_8)))\r\n\r\n\r\n(uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n\r\n;; => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\n\r\n(uuid/v5 uuid/+namespace-url+ (java.net.URL. \"http://example.com/\"))\r\n\r\n;; => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\n```\r\n\r\n\r\n##### Hierarchical Namespace\r\n\r\nBecause each UUID denotes its own namespace, it is easy to compose v5\r\nidentifiers in order to represent hierarchical sub-namespaces.  This,\r\nfor example, can be used to assign unique identifiers based not only\r\non the content of a string but the unique identity representing its\r\nsource or provenance:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n        \"resource1#\")\r\n\r\n;;  => #uuid \"6a3944a4-f00e-5921-b8b6-2cea5a745132\"\r\n\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n        \"resource2#\")\r\n\r\n;;  => #uuid \"98879e2a-8511-59ab-877d-ac6f8667866d\"\r\n\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://other.com/\")\r\n        \"resource1#\")\r\n\r\n;;  => #uuid \"bc956d0c-7af3-5b81-89f2-a96e8f9fd1a8\"\r\n\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://other.com/\")\r\n        \"resource2#\")\r\n\r\n;;  => #uuid \"a38b24fe-7ab8-58c8-a3f8-d3adb308260b\"\r\n\r\n\r\n```\r\n\r\nBecause UUID's and namespaces can be chained together like this, one\r\ncan be certain that the UUID resulting from a chain of calls such as\r\nthe following will be unique -- if and only if the original namespace\r\nmatches:\r\n\r\n\r\n```clojure\r\n\r\nuser> (-> (uuid/v1)\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"eb7a0c2b-eb0e-5bb2-9819-3c9edc2814fa\"\r\n\r\n\r\nuser> (-> (uuid/v1)\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"45e8c272-1660-57ba-8892-6844e1d3196a\"\r\n\r\n```\r\n\r\n\r\nAt each step, the local part string must be identical, in order for the the\r\nfinal UUID to match:\r\n\r\n```clojure\r\n\r\nuser> (-> uuid/+namespace-dns+\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"617756cc-3b02-5a86-ad4a-ab3e1403dbd6\"\r\n\r\n\r\nuser> (-> uuid/+namespace-dns+\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"52d5453e-2aa1-53c1-b093-0ea20ef57ad1\"\r\n\r\n```\r\n\r\nThis capability can be used to represent uniqueness of a sequence of\r\ncomputations in, for example, a transaction system such as the one\r\nused in the graph-object database system\r\n[de.setf.resource](http://github.com/lisp/de.setf.resource/) or this\r\ninteresting new [CQRS/ES Server](http://yuppiechef.github.io/cqrs-server/). \r\n\r\n### A Simple Example\r\n\r\nOk, so now you know how to use this nifty new UUID library and you are\r\nburning up to do something awesome with UUID's... But, ah, hmmm... First\r\nyou need to figure out what exactly you want to do with them.  Well,\r\nbefore you start working on your distributed cloud-based secret\r\nweapon, here is a simple way you can generate cryptographically\r\nsecure activation keys for your draconian licensing scheme.\r\n\r\nFirst, we pick a secret key.  We might pick a time-based id, or we might\r\nbegin with some secret namespace, secret identifier pair to compute that\r\ninitial namespace deterministically.  This is convenient, but not necessary\r\n-- the time-based or random private key could also be stored in some form\r\nof persistent memory.  As unguessability important to deter hackers, we will\r\nchoose a random namespace and record it in some secret, persistent storage\r\nto ensure we can regenerate a user's activation code identically on-demand\r\nin the future.\r\n\r\n```clojure\r\n\r\nuser> (def +secret-weapon-licensing-namespace+ (uuid/v4))\r\n\r\n\r\nuser> (uuid/v5 +secret-weapon-licensing-namespace+ \"joe@example.com\")\r\n\r\n;;  => #uuid \"b6433d1e-d369-5282-8dbc-bdd3845c376c\"\r\n\r\n\r\nuser> (uuid/v5 +secret-weapon-licensing-namespace+ \"mom@knitting-arts.edu\")\r\n\r\n;;  => #uuid \"81e4708c-85bb-5f3c-be56-bba4d8b0ac91\"\r\n\r\n```\r\n\r\nNow, as the orders start rolling in for your product, you can crank out\r\nsecret weapon activation codes just as well as if you were Microsoft.\r\nEach one will be keyed to a user's email address and is guaranteed\r\nto be irreversible.  You will infuriate them with unreasonably high\r\nmaintence support contract fees and intractible licensing terms.\r\nYou truly are diabolical.\r\n\r\n\r\n### Basic API\r\n\r\n* * * * * *\r\n\r\n#### Namespaces\r\n\r\n_(var)_         `+null+`\r\n\r\n> `#uuid \"00000000-0000-0000-0000-000000000000\"`\r\n\r\n\r\n_(var)_         `+namespace-dns+`\r\n\r\n> `#uuid \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-url+`\r\n\r\n> `#uuid \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-oid+`\r\n\r\n> `#uuid \"6ba7b812-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-x500+`\r\n\r\n> `#uuid \"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n* * * * * *\r\n\r\n#### Generators\r\n\r\n_(function)_    `v0 []`\r\n\r\n> Return the null UUID, #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\n_(function)_    `v1 []`\r\n\r\n>  Generate a v1 (time-based) unique identifier, guaranteed to be unique\r\n>  and thread-safe regardless of clock precision or degree of concurrency.\r\n>  Creation of v1 UUID's does not require any call to a cryptographic \r\n>  generator and can be accomplished much more efficiently than v1, v3, v5,\r\n>  or squuid's.  A v1 UUID reveals both the identity of the computer that \r\n>  generated the UUID and the time at which it did so.  Its uniqueness across \r\n>  computers is guaranteed as long as MAC addresses are not duplicated.\r\n\r\n\r\n_(function)_    `v3 [^UUID namespace ^Object local-name]`\r\n\r\n>  Generate a v3 (name based, MD5 hash) UUID. context' must be UUIDable.\r\n>  v3 identifiers are intended for generating UUID's from names that are \r\n>  drawn from, and unique within, some namespace.  The concept of name and \r\n>  namespace should be broadly construed, and not limited to textual names.\r\n>  The requiremens for a v3 UUID are as follows:\r\n>\r\n>  * v3 UUID's generated at different times from the same name in the same\r\n>    namespace MUST be equal.\r\n>\r\n>  * v3 UUID's generated from two different names in the same namespace\r\n>    SHOULD be distinct with a high degree of certainty.\r\n>\r\n>  * v3 UUID's generated from the same name in two different namespaces\r\n>    SHOULD be distinct with a high degree of certainty.\r\n>\r\n>  * If two v3 UUID's are equal, then there is a high degree of certainty\r\n>    that they were generated from the same name in the same namespace.\r\n\r\n_(function)_    `v4 []`\r\n\r\n_(function)_    `v4 [^long msb, ^long lsb]`\r\n\r\n>  Generate a v4 (random) UUID.  Uses default JVM implementation.  If two\r\n>  arguments, lsb and msb (both long) are provided, then construct a valid,\r\n>  properly formatted v4 UUID based on those values.  So, for example the\r\n>  following UUID, created from all zero bits, is indeed distinct from the\r\n>  null UUID:\r\n>\r\n>      (v4)\r\n>       => #uuid \"dcf0035f-ea29-4d1c-b52e-4ea499c6323e\"\r\n>\r\n>      (v4 0 0)\r\n>       => #uuid \"00000000-0000-4000-8000-000000000000\"\r\n>\r\n>      (null)\r\n>       => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\n_(function)_    `v5 [^UUID namespace ^Object local-name]`\r\n\r\n>  Generate a v5 (name based, SHA1 hash) UUID. 'context' must be UUIDable.\r\n>  v5 identifiers are intended for generating UUID's from names that are \r\n>  drawn from, and unique within, some namespace.  The concept of name and \r\n>  namespace should be broadly construed, and not limited to textual names.\r\n>  The requiremens for a v5 UUID are as follows:\r\n>\r\n>  * v5 UUID's generated at different times from the same name in the same\r\n>    namespace MUST be equal.\r\n>\r\n>  * v5 UUID's generated from two different names in the same namespace\r\n>    SHOULD be distinct with a high degree of certainty.\r\n>\r\n>  * v5 UUID's generated from the same name in two different namespaces\r\n>    SHOULD be distinct with a high degree of certainty.\r\n>\r\n>  * If two v5 UUID's are equal, then there is a high degree of certainty\r\n>    that they were generated from the same name in the same namespace.\r\n\r\n\r\n_(function)_    `squuid []`\r\n\r\n>  Generate a SQUUID (sequential, random) unique identifier.  SQUUID's\r\n>  are a nonstandard variation on v4 (random) UUIDs that have the\r\n>  desirable property that they increase sequentially over time as well\r\n>  as encode retrievably the posix time at which they were generated.\r\n>  Splits and reassembles a v4 UUID to merge current POSIX\r\n>  time (seconds since 12:00am January 1, 1970 UTC) with the most\r\n>  significant 32 bits of the UUID\r\n  \r\n\r\n_(function)_    `monotonic-time []`\r\n\r\n>  Return a monotonic timestamp (guaranteed always increasing)  based on \r\n>  the number of 100-nanosecond intervals elapsed since the adoption of the \r\n>  Gregorian calendar in the West, 12:00am Friday October 15, 1582 UTC.\r\n\r\n* * * * * *\r\n\r\n#### Protocols\r\n\r\n_(protocol)_    `UUIDNameBytes`\r\n\r\n>  A mechanism intended for user-level extension that defines the\r\n>  decoding rules for the local-part representation of arbitrary\r\n>  Clojure / Java Objects when used for computing namespaced\r\n>  identifiers.\r\n>\r\n> _(member)_    `as-byte-array [self]`\r\n>\r\n>>  Extract a byte serialization that represents the 'name' of x, \r\n>>  typically unique within a given namespace.\r\n\r\n\r\n_(protocol)_    `UUIDable`\r\n\r\n>  A UUIDable object directly represents a UUID.  Examples of things which\r\n>  might be conceptually 'uuidable' include string representation of a\r\n>  UUID in canonical hex format, or an appropriate URN URI.\r\n>\r\n> _(member)_    `as-uuid [self]`\r\n>\r\n>>  Coerce the value of `self` to a java.util.UUID.\r\n>\r\n> _(member)_    `uuidable? [self]`\r\n>\r\n>>  Return 'true' if `self` can be coerced to UUID.\r\n\r\n\r\n_(protocol)_    `UUIDRfc4122`\r\n\r\n>  A protocol that abstracts an unique identifier as described by\r\n>  IETF RFC4122 <http://www.ietf.org/rfc/rfc4122.txt>. A UUID\r\n>  represents a 128-bit value, however there are variant encoding\r\n>  layouts used to assign and interpret information encoded in\r\n>  those bits.  This is a protocol for  _variant 2_ (*Leach-Salz*) \r\n>  UUID's.\r\n>\r\n> _(member)_    `null? [self]`\r\n>\r\n>>  Return `true` only if `self` has all 128 bits set ot zero and is \r\n>>  therefore equal to the null UUID, `00000000-0000-0000-0000-000000000000`.\r\n>\r\n> _(member)_    `uuid? [self]`\r\n>\r\n>>  Return `true` if the class of `self` implements an RFC4122 unique identifier.\r\n>\r\n> _(member)_    `uuid= [self other]`\r\n>\r\n>>  Directly compare two UUID's for `=` relation based on the equality\r\n>>  semantics defined by [RFC4122:3 \"RULES FOR LEXICAL EQUIVALENCE\"].\r\n>\r\n> _(member)_    `uuid< [self other]`\r\n>\r\n>>  Directly compare two UUID's for `<` relation based on the ordinality\r\n>>  semantics defined by [RFC4122:3 \"RULES FOR LEXICAL EQUIVALENCE\"].\r\n>\r\n> _(member)_    `uuid> [self other]`\r\n>\r\n>>  Directly compare two UUID's for `>` relation based on the ordinality\r\n>>  semantics defined by [RFC4122:3 \"RULES FOR LEXICAL EQUIVALENCE\"].\r\n>\r\n> _(member)_    `get-word-high [self]`\r\n>\r\n>>  Return the most significant 64 bits of the 128 bit value of UUID `self`.\r\n>\r\n> _(member)_    `get-word-low [self]`\r\n>\r\n>>  Return the least significant 64 bits of the 128 bit value of UUID `self`.\r\n>\r\n> _(member)_    `get-variant [self]`\r\n>\r\n>>  Return the _variant_ number associated with this UUID.  The variant field \r\n>>  contains a value which identifies the layout of the UUID.  The bit-layout \r\n>>  implemented by this protocol supports UUID's with a variant value of 0x2,\r\n>>  which indicates Leach-Salz layout.  Defined UUID variant values are:\r\n>>\r\n>>     0x0   Null \r\n>>     0x2   Leach-Salz\r\n>>     0x6   Microsoft \r\n>>     0x7   Reserved for future assignment\r\n>>\r\n>>  In the canonical representation, `xxxxxxxx-xxxx-xxxx-Nxxx-xxxxxxxxxxxx`,\r\n>>  the most significant bits of N indicate the variant (depending on the\r\n>>  variant one, two, or three bits are used). The variant covered by RFC4122\r\n>>  is indicated by the two most significant bits of `N` being `1 0` (i.e., the \r\n>>  hexadecimal `N` will always be `8`, `9`, `A`, or `B`).\r\n>\r\n> _(member)_    `get-version [self]`\r\n>\r\n>>  Return the _version_ number associated with this UUID.  The version\r\n>>  field contains a value which describes the nature of the UUID.  There\r\n>>  are five versions of Leach-Salz UUID, plus the null UUID:\r\n>>\r\n>>     0x0   Null\r\n>>     0x1   Time based\r\n>>     0x2   DCE security with POSIX UID\r\n>>     0x3   Namespaced (MD5 Digest)\r\n>>     0x4   Cryptographic random\r\n>>     0x5   Namespaced (SHA1 Digest)\r\n>>\r\n>>  In the canonical representation, `xxxxxxxx-xxxx-Mxxx-xxxx-xxxxxxxxxxxx`, \r\n>>  the four bits of `M` indicate the UUID version (i.e., the hexadecimal `M`\r\n>>  will be either `1`, `2`, `3`, `4`, or `5`).\r\n>\r\n> _(member)_    `get-timetamp [self]`\r\n>\r\n>>  Return the 60 bit unsigned value that represents a temporally unique\r\n>>  timestamp associated with this UUID.  For time-based (v1) UUID's the\r\n>>  result encodes the number of 100 nanosecond intervals since the\r\n>>  adoption of the Gregorian calendar: _12:00am Friday October 15, 1582 UTC_.\r\n>>  For non-time-based (v3, v4, v5, squuid) UUID's, always returns `nil`.\r\n>\r\n> _(member)_    `get-instant [self]`\r\n>\r\n>>  For time-based (v1) UUID's, return a `java.util.Date` object that represents\r\n>>  the system time at which this UUID was generated. NOTE: the returned\r\n>>  value may not necessarily be temporally unique. For non-time-based \r\n>>  (v3, v4, v5, squuid) UUID's, always returns `nil`.\r\n>\r\n> _(member)_    `get-time-low [self]`\r\n>\r\n>>  Return the 32 bit unsigned value that represents the _time-low_ field\r\n>>  of the _timestamp_ associated with this UUID.\r\n>\r\n> _(member)_    `get-time-mid [self]`\r\n>\r\n>>  Return the 16 bit unsigned value that represents the _time-mid_ field\r\n>>  of the _timestamp_ assocaited with this UUID.\r\n>\r\n> _(member)_    `get-time-high [self]`\r\n>\r\n>>  Return the 16 bit unsigned value that represents the _time-high_ field\r\n>>  of the _timestamp_ multiplexed with the _version_ of this UUID.\r\n>\r\n> _(member)_    `get-clk-seq [self]`\r\n>\r\n>>  Return the _clk-seq_ number associated with this UUID. For time-based\r\n>>  (v1) UUID's the _clock-sequence_ value is a somewhat counter-intuitively named \r\n>>  seed-value that is used to reduce the potential that duplicate UUID's \r\n>>  might be generated under unusual situations, such as if the system hardware\r\n>>  clock is set backward in time or if, despite all efforts otherwise, a \r\n>>  duplicate `+node-id+` happens to be generated. This value is initialized to \r\n>>  a random 16-bit number once per lifetime of the system.  For non-time-based\r\n>>  (v3, v4, v5, squuid) UUID's, always returns `nil`.\r\n>\r\n> _(member)_    `get-clk-high [self]`\r\n>\r\n>>  Return the 8 bit unsigned value that represents the most significant\r\n>>  byte of the _clk-seq_ multiplexed with the _variant_ of this UUID.\r\n>\r\n> _(member)_    `get-clk-low [self]`\r\n>\r\n>>  Return the 8 bit unsigned value that represents the least significant\r\n>>  byte of the _clk-seq_ associated with this UUID.\r\n>\r\n> _(member)_    `get-node-id [self]`\r\n>\r\n>>  Return the 48 bit unsigned value that represents the spatially unique\r\n>>  _node identifier_ associated with this UUID.\r\n>\r\n> _(member)_    `hash-code [self]`\r\n>\r\n>>  Return a suitable 64-bit hash value for `self`.  Extend for\r\n>>  specialized hash computation.\r\n>\r\n> _(member)_    `to-byte-array [self]`\r\n>\r\n>>  Return an array of 16 bytes that represents `self` as a decomposed \r\n>>  octet serialization encoded in most-significant-byte first order.\r\n>\r\n> _(member)_    `to-string [self]`\r\n>\r\n>>  Return a String object that represents `self` in the canonical \r\n>>  36 character hexadecimal string format: \r\n>>\r\n>>     \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\r\n>\r\n> _(member)_    `to-hex-string [self]`\r\n>\r\n>>  Return a String object that represents `self` as the 32 hexadecimal \r\n>>  characters directly encodong the UUID's 128 bit value: \r\n>>\r\n>>     \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\r\n>\r\n> _(member)_    `to-urn-string [self]`\r\n>\r\n>>  Return a String object that represents `uuid` as a the string \r\n>>  serialization of the URN URI based on the canonical 36 character \r\n>>  hex-string representation: \r\n>>\r\n>>     \"urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\r\n>\r\n> _(member)_    `to-uri [self]`\r\n>\r\n>>  Return the unique URN URI associated with this UUID.\r\n\r\n\r\n\r\n### References\r\n\r\n* [IETF RFC-4122](http://www.ietf.org/rfc/rfc4122.txt) _A Universally Unique IDentifier (UUID) URN Namespace_ \r\n\r\n* [Wikipedia/_Universally unique identifier_](http://en.wikipedia.org/wiki/Universally_unique_identifier)\r\n\r\n* [CL-UUID](http://www.dardoria.net/software/uuid.html) reference implementation \r\n\r\n* [UNICLY](https://github.com/mon-key/unicly) reference implementation\r\n\r\n* [java.util.UUID](http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html) JavaDoc\r\n\r\n* [Java and Unsigned Primitive Datatypes](http://www.darksleep.com/player/JavaAndUnsignedTypes.html)\r\n\r\n* [The web of names, hashes, and UUIDs](http://joearms.github.io/2015/03/12/The_web_of_names.html)\r\n\r\n* [Coding Katas Clojure -- Bloom Filters](http://blog.find-method.de/index.php?/archives/200-Coding-katas-Clojure-Bloom-filters.html)\r\n\r\n\r\n### License\r\n\r\nCopyright Â© 2015 Dan Lentz\r\n\r\nDistributed under the Eclipse Public License version 1.0 \r\n\r\n\r\n","google":"UA-37992128-5","note":"Don't delete this file! It's used internally to help with page regeneration."}