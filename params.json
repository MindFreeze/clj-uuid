{"name":"clj-uuid","tagline":"A Clojure library extending java.util.UUID with true v1 (time based) and v3/v5 (namespace based) identifiers","body":"clj-uuid\r\n========\r\n\r\n[![Build Status](https://travis-ci.org/danlentz/clj-uuid.svg?branch=master)]\r\n(https://travis-ci.org/danlentz/clj-uuid)\r\n[![Dependency Status](https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.2-SNAPSHOT/badge.svg)](https://www.versioneye.com/clojure/danlentz:clj-uuid/0.1.2-SNAPSHOT)\r\n\r\n* * * * * *\r\n\r\n**clj-uuid** is a Clojure library for generation and utilization of\r\nUUIDs (Universally Unique Identifiers) as described by RFC-4122.\r\nThis library extends the standard Java UUID class to provide true v1\r\n(time based) and v3/v5 (namespace based) identifier generation.\r\nAdditionally, a number of useful supporting utilities are provided to\r\nsupport serialization and manipulation of these UUIDs in a simple,\r\nefficient manner.\r\n\r\nThe essential nature of the value RFC4122 UUIDs provide is that of an\r\nenormous namespace and a deterministic mathematical model by means of\r\nwhich one navigates it. UUIDs represent an extremely powerful and\r\nversatile computation technique that is often overlooked, and\r\nunderutilized. In my opinion, this, in part, is due to the generally\r\npoor quality, performance, and capability of available libraries and,\r\nin part, due to a general misunderstanding in the popular consiousness\r\nof their proper use and benefit. It is my hope that this library will\r\nserve to expand awareness, make available, and simplify use of RFC4122\r\nidentifiers to a wider audience.\r\n\r\n\r\n\r\n### The Most Recent Release\r\n\r\nWith Leiningen:\r\n\r\n![Clojars Project](http://clojars.org/danlentz/clj-uuid/latest-version.svg)\r\n\r\n\r\n### How is it better?\r\n\r\nThe JVM version only provides an automatic builder for random (v4)\r\nand (non-namespaced) pseudo-v3 UUID's.  Where appropriate, this library\r\ndoes use the internal JVM UUID implementation.  The benefit with this library\r\nis that clj-uuid provides an easy way to get v1 and true namespaced v3 and\r\nv5 UUIDs.  v3/v5 UUID's are necessary because many of the interesting things\r\nthat you can do with UUID's require namespaced identifiers. v1 UUIDs are\r\nreally useful because they can be generated faster than v4's as they don't\r\nneed to call a cryptographic random number generator.\r\n\r\n\r\n### How Big?\r\n\r\nThe provided namespace represents an _inexhaustable_ resource and as\r\nsuch can be used in a variety of ways not feasible using traditional\r\ntechniques rooted in the notions imposed by finite resources.  When I\r\nsay \"inexhaustable\" this of course is slight hyperbolie, but not by\r\nmuch.  The upper bound on the representation implemented by this\r\nlibrary limits the number of unique identifiers to a mere...\r\n\r\n*three hundred forty undecillion two hundred eighty-two decillion three*\r\n*hundred sixty-six nonillion nine hundred twenty octillion nine hundred* \r\n*thirty-eight septillion four hundred sixty-three sextillion four hundred*\r\n*sixty-three quintillion three hundred seventy-four quadrillion six hundred*\r\n*seven trillion four hundred thirty-one billion seven hundred sixty-eight*\r\n*million two hundred eleven thousand four hundred and fifty-five.*\r\n\r\nIf you think you might be starting to run low, let me know when you get down\r\nto your last few undecillion or so and I'll see what I can do to help out.\r\n\r\n\r\n### Usage\r\n\r\nUsing clj-uuid is really easy.  Docstrings are provided, but sometimes\r\nexamples help, too.  The following cases demonstrate about 90% of the\r\nfunctionality that you are likely to ever need.\r\n\r\nIn order to refer to the symbols in this library, it is recommended to\r\n*require* it in a given namespace:\r\n\r\n```clojure\r\n\r\n(require '[clj-uuid :as uuid])\r\n```\r\n\r\nOr include in namespace declaration:\r\n\r\n\r\n```clojure\r\n\r\n(ns foo\r\n  (:require [clj-uuid :as uuid])\r\n  ...\r\n  )\r\n\r\n```\r\n\r\n\r\n#### Literal Syntax\r\n\r\nUUID's have a convenient literal syntax supported by the clojure\r\nreader.  The tag `#uuid` denotes that the following string literal\r\nwill be read as a UUID.  UUID's evaluate to themselves:\r\n\r\n```clojure\r\n\r\nuser> #uuid \"e6ff478d-9492-48dd-886d-23ec4c6385ee\"\r\n\r\n;;  => #uuid \"e6ff478d-9492-48dd-886d-23ec4c6385ee\"\r\n```\r\n\r\n\r\n#### The NULL (v0) Identifier\r\n\r\nThe special UUID, `#uuid \"00000000-0000-0000-0000-000000000000\"` is\r\nknown as the _null UUID_ or _version 0 UUID_ and can be useful for\r\nrepresenting special values such as _nil_ or _null-context. One may\r\nreference the null UUID declaratively or functionally, although it is\r\nbest to pick one convention and remain consistant.\r\n\r\n\r\n```clojure\r\n\r\nuser> (uuid/null)\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\nuser> (uuid/v0)\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\nuser> uuid/+null+\r\n\r\n;;  => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n```\r\n\r\n\r\n#### Time Based (v1) Identifiers\r\n\r\nYou can make your own v1 UUID's with the function `#'uuid/v1`.  These\r\nUUID's will be guaranteed to be unique and thread-safe regardless of\r\nclock precision or degree of concurrency.\r\n\r\nA v1 UUID may reveal both the identity of the computer that generated\r\nthe UUID and the time at which it did so.  Its uniqueness across\r\ncomputers is guaranteed as long as node/MAC addresses are not duplicated.\r\n  \r\n\r\n```clojure\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"ffa803f0-b3d3-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"005b7570-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"018a0a60-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\nuser> (uuid/v1)\r\n\r\n;;  => #uuid \"02621ae0-b3d4-11e4-a03e-3af93c3de9ae\"\r\n\r\n```\r\n\r\n\r\nV1 identifiers are the fastest kind of UUID to generate -- about 25%\r\nfaster than calling the JVM's built-in static method for generating ids,\r\n`#'java.util.UUID/randomUUID`.\r\n\r\n\r\n```\r\nuser> (criterium.core/bench (uuid/v1))\r\n\r\nEvaluation count : 41142600 in 60 samples of 685710 calls.\r\nExecution time mean : 1.499075 Âµs\r\n```\r\n\r\n\r\n#### Random (v4) Identifiers\r\n\r\n\r\nV4 identifiers are generated by directly invoking the static method\r\n`#'java.util.UUID/randomUUID` and are, in typical situations, slower\r\nto generate in addition to being non-deterministically unique.\r\n\r\n\r\n```\r\nuser> (criterium.core/bench (uuid/v4))\r\n\r\nEvaluation count : 31754100 in 60 samples of 529235 calls.\r\nExecution time mean : 1.928087 Âµs\r\n```\r\n\r\n\r\n#### Namespaced (v3/v5) Identifiers\r\n\r\nIf you are familiar wit Clojure _vars_, you already understand the\r\nidea of _namespaced_ identifiers.  To resolve the value of a var, one\r\nneeds to know not only the _name_ of a var, but also the _namespace_\r\nit resides in.  It is intuitively clear that vars `#'user/x` and\r\n`#'library/x` are distinct.  Namespaced UUID's follow a similar\r\nconcept, however namespaces are themselves represented as UUID's.\r\nNames are strings that encode a representation of a symbol or value in\r\nthe namespace of that identifier.  Given a namespace and a local-name,\r\none can always (re)construct the unique identifier that represents\r\nit.  We can demonstrate a few examples constructed using several of\r\nthe canonical top level namespace UUIDs:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n\r\n;;  => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\nuser> (uuid/v5 uuid/+namespace-x500+ \"http://example.com/\")\r\n\r\n;;  => #uuid \"0cb29677-4eaf-578f-ab9b-f9ac67c33cb9\"\r\n\r\n\r\nuser> (uuid/v3 uuid/+namespace-dns+ \"www.clojure.org\")\r\n\r\n;;  => #uuid \"3bdca4f7-fc85-3a8b-9038-7626457527b0\"\r\n\r\n\r\nuser> (uuid/v5 uuid/+namespace-oid+ \"0.1.22.13.8.236.1\")\r\n\r\n;;  => #uuid \"9989a7d2-b7fc-5b6a-84d6-556b0531a065\"\r\n```\r\n\r\nYou can see in each case that the local \"name\" string is given in some\r\nwell-definted format specific to each namespace.  This is a very\r\ncommon convention, but not enforced.  It is perfectly valid to\r\nconstruct a namespaced UUID from any literal string.\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ \"I am clearly not a URL\")\r\n\r\n;;  => #uuid \"a167a791-e550-57ae-b20f-666ee47ce7c1\"\r\n```\r\n\r\nThe only difference between v3 and v5 UUID's is that v3's are computed\r\nusing an MD5 digest algorithm and v5's are computed using SHA1.  It is\r\ngenerally considered that SHA1 is a superior hash, but MD5 is\r\ncomputationally less expensive and so v3 may be preferred in\r\nsituations requiring slightly faster performance.\r\n\r\nAs a matter of fact, the requirements for a valid the local-part\r\nconstituent are even more general than even just Strings.  Any kind of\r\nobject can be used:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5 uuid/+namespace-url+ :keyword)\r\n\r\n;;  => #uuid \"bc480d53-fba7-5e5f-8f33-6ad77880a007\"\r\n\r\n```\r\n\r\nThis will be most efficient for classes of object that have been\r\nextended with the `UUIDNameBytes` protocol.  If one intends to do such\r\na thing fequently, it is a simple matter to specialize an\r\n`as-byte-array` method which can extract a unique sequence of bytes\r\nfrom an arbitrary class of input data.  Here is a simple example where\r\none adds specialized support for URLs to be quickly digested as the bytes of\r\ntheir string representation:\r\n\r\n\r\n```clojure\r\n\r\n(extend-protocol UUIDNameBytes java.net.URL\r\n  (as-byte-array [this]\r\n    (.getBytes (.toString this) StandardCharsets/UTF_8)))\r\n\r\n\r\n(uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n\r\n;; => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\n\r\n(uuid/v5 uuid/+namespace-url+ (java.net.URL. \"http://example.com/\"))\r\n\r\n;; => #uuid \"0a300ee9-f9e4-5697-a51a-efc7fafaba67\"\r\n\r\n```\r\n\r\n\r\n##### Hierarchical Namespace\r\n\r\nBecause each UUID denotes its own namespace, it is easy to compose v5\r\nidentifiers in order to represent hierarchical sub-namespaces.  This,\r\nfor example, can be used to assign unique identifiers based not only\r\non the content of a string but the unique identity representing its\r\nsource or provenance:\r\n\r\n```clojure\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n        \"resource1#\")\r\n\r\n;;  => #uuid \"6a3944a4-f00e-5921-b8b6-2cea5a745132\"\r\n\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://example.com/\")\r\n        \"resource2#\")\r\n\r\n;;  => #uuid \"98879e2a-8511-59ab-877d-ac6f8667866d\"\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://other.com/\")\r\n        \"resource1#\")\r\n\r\nuser> (uuid/v5\r\n        (uuid/v5 uuid/+namespace-url+ \"http://other.com/\")\r\n        \"resource2#\")\r\n\r\n\r\n```\r\n\r\nBecause UUID's and namespaces can be chained together like this, one\r\ncan be certain that the UUID resulting from a chain of calls such as\r\nthe following will be unique -- if and only if the original namespace\r\nmatches:\r\n\r\n\r\n```clojure\r\n\r\nuser> (-> (uuid/v1)\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"eb7a0c2b-eb0e-5bb2-9819-3c9edc2814fa\"\r\n\r\n\r\nuser> (-> (uuid/v1)\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"45e8c272-1660-57ba-8892-6844e1d3196a\"\r\n\r\n```\r\n\r\n\r\nAt each step, the local part string must be identical, in order for the the\r\nfinal UUID to match:\r\n\r\n```clojure\r\n\r\nuser> (-> uuid/+namespace-dns+\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"617756cc-3b02-5a86-ad4a-ab3e1403dbd6\"\r\n\r\n\r\nuser> (-> uuid/+namespace-dns+\r\n        (uuid/v5 \"two\")\r\n        (uuid/v5 \"one\")\r\n        (uuid/v5 \"three\"))\r\n\r\n;;  => #uuid \"52d5453e-2aa1-53c1-b093-0ea20ef57ad1\"\r\n\r\n```\r\n\r\nThis capability can be used to represent uniqueness of a sequence of\r\ncomputations in, for example, a transaction system such as the one\r\nused in the graph-object database system\r\n[de.setf.resource](http://github.com/lisp/de.setf.resource/). \r\n\r\n\r\n\r\n### Basic API\r\n\r\n* * * * * *\r\n\r\n_(var)_         `+null+`\r\n\r\n> `#uuid \"00000000-0000-0000-0000-000000000000\"`\r\n\r\n\r\n_(var)_         `+namespace-dns+`\r\n\r\n> `#uuid \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-url+`\r\n\r\n> `#uuid \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-oid+`\r\n\r\n> `#uuid \"6ba7b812-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n\r\n_(var)_         `+namespace-x500+`\r\n\r\n> `#uuid \"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"`\r\n\r\n* * * * * *\r\n\r\n_(function)_    `v0 []`\r\n\r\n> Return the null UUID, #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\n_(function)_    `v1 []`\r\n\r\n>  Generate a v1 (time-based) unique identifier, guaranteed to be unique\r\n>  and thread-safe regardless of clock precision or degree of concurrency.\r\n>  Creation of v1 UUID's does not require any call to a cryptographic \r\n>  generator and can be accomplished much more efficiently than v1, v3, v5,\r\n>  or squuid's.  A v1 UUID reveals both the identity of the computer that \r\n>  generated the UUID and the time at which it did so.  Its uniqueness across \r\n>  computers is guaranteed as long as MAC addresses are not duplicated.\r\n\r\n\r\n_(function)_    `v3 [^UUID namespace ^String local-name]`\r\n\r\n>  Generate a v3 (name based, MD5 hash) UUID.\r\n\r\n\r\n_(function)_    `v4 []`\r\n\r\n_(function)_    `v4 [^long msb, ^long lsb]`\r\n\r\n>  Generate a v4 (random) UUID.  Uses default JVM implementation.  If two\r\n>  arguments, lsb and msb (both long) are provided, then construct a valid,\r\n>  properly formatted v4 UUID based on those values.  So, for example the\r\n>  following UUID, created from all zero bits, is indeed distinct from the\r\n>  null UUID:\r\n>\r\n>      (v4)\r\n>       => #uuid \"dcf0035f-ea29-4d1c-b52e-4ea499c6323e\"\r\n>\r\n>      (v4 0 0)\r\n>       => #uuid \"00000000-0000-4000-8000-000000000000\"\r\n>\r\n>      (null)\r\n>       => #uuid \"00000000-0000-0000-0000-000000000000\"\r\n\r\n\r\n_(function)_    `v5 [^UUID namespace ^String local-name]`\r\n\r\n>  Generate a v5 (name based, SHA1 hash) UUID.\r\n\r\n\r\n_(function)_    `squuid []`\r\n\r\n> \"Generate a SQUUID (sequential, random) unique identifier.  SQUUID's\r\n>  are a nonstandard variation on v4 (random) UUIDs that have the\r\n>  desirable property that they increase sequentially over time as well\r\n>  as encode retrievably the posix time at which they were generated.\r\n>  Splits and reassembles a v4 UUID to merge current POSIX\r\n>  time (seconds since 12:00am January 1, 1970 UTC) with the most\r\n>  significant 32 bits of the UUID\r\n  \r\n* * * * * *\r\n\r\n### Motivation\r\n\r\nTo a large extent, the design of the algorithmic\r\nimplementation is inspired by the Common-Lisp library\r\n[_UNICLY_](http://github.com/mon-key/unicly) which is a painstakingly\r\noptimized, encyclopaedic implementation of RFC-4122 the author of\r\nwhich, Stan Pearman, has devoted considerable effort to research, refine, and\r\nimprove.  To my knowledge there is no more performant  and\r\nprecise implementation of the RFC-4122 specification available\r\nanywhere, in any language, on any platform.\r\n\r\nThat having been said, this library intends to present a slightly more\r\ncomfortable public interface that places a little more priority on\r\nconvenient DWIM semantics at the cost of somewhat less emphasis on\r\nlow level performance optimizations.  Since this library is built as\r\nan extension to the standard java.util.UUID class whose implementation\r\nlargely dominates its performance characteristics anyway, this seems to\r\nbe a reasonable philosophy.\r\n\r\n### License\r\n\r\nCopyright Â© 2015 Dan Lentz\r\n\r\nDistributed under the Eclipse Public License either version 1.0 \r\n\r\n\r\n\r\n\r\n","google":"UA-37992128-5","note":"Don't delete this file! It's used internally to help with page regeneration."}